Thread 객체

배우기 전 OS때 배웠던 내용 복습(사전 학습)



Program
확장자가 exe인 파일을 의미 (명령어들이 모인 파일)

(프로세스 수 >=프로그램 수) 공식이 성립(프로그램 규모에 따라 프로세스 수는 달라짐)


Process
작업의 단위

(+)비슷한 의미로 Transaction이 있다.
다른 점은 트랜잭션은 정확히 더 이상 쪼갤 수 없는 작업의 최소단위이다.(DB론에서 사용)



프로세스의 구성요소(대략적인 구성)


heap data code

Thread(stack 포함)(Thread는 여럿일 수 있음(멀티쓰레드))


결국 (쓰레드 수>=프로세스 수) 이 공식이 성립할 수밖에 없다.



즉 삼단 논법에 의해 

쓰레드 수 >=프로그램 수도 성립하고

쓰레드 수 >= 프로세스 수 >= 프로그램 수 가 성립!



실제로 작업관리자로 직접 한 프로그램 내에 얼마나 많은 쓰레드들이 있는지 확인도 해봤음

작업관리자 >> 성능 탭 >> 프로세스는 100 몇개 밖에 안되지만 몇 천개의 쓰레드 들이 존재한다는 것을 확인
(프로세스와 쓰레드가 꼭1:1대응이 아니고 1:多 도 있다는 것을 깨달음)

추가로 프로세스 탭을 뒤져보다 '서비스'라는 개념 또한 알게 되었다

 서비스라는 개념도 존재하는 데 이는 프로그램 내에서 주체 쓰레드라고 불리우며



Thread
Process를 수행하는 하나의 로직(흐름)

프로세스를 이행하는 "주체"라고 표현하는 사람이나 사이트도 있었지만
흐름이나 로직으로 표현하는 것이 많이 보여서 나는 흐름이나 로직으로 정의하는 것이 맞다고 본다.

MultiThread
하나의 프로세스에 둘 이상의 쓰레드가 들어갈 수 있는 기능


나중에 또 면접 준비할 때 다시 정리해야하는 불상사가 없도록 확실히 정리 해놓는다!



프로세스 상태 개념(OS 때 배움)

Thread 생명주기 & 상태를 만들고 해지 가능한 조건

new(생성) 프로세스가 메모리에 할당되어 실행 준비를 완료한 상태.

ready(준비) 생성된 프로세스가 cpu를 얻을때까지 기다리는 상태(start()가 호출된 상태)

running(수행) 준비상태에 있는 프로세스 중 하나가 cpu를 얻어 실제 작업을 수행하는 상태

waitng(대기) 실행상태에 있는 프로세스가 입출력을 요청하면 입출력이 완료될 때까지 기다리는 상태

종료(exit): 프로세스가 종료된 상태








Thread로 만들어서 실행하는 방법

extends Thread 상속을 받은 클래스는 쓰레드 관련 메소드 사용가능!(Runnable 인터페이스 상속!)


run()메소드 오버라이딩 후 run 메소드 구현파트에 thread로 병렬처리할 실행할 실행문들을 기입한다.


객체 생성 할당 후 start메소드를 호출하여 쓰레드 실행!





sleep() 강사님께서 예전에 딜레이 주실때 쓰신 적 있음(1000분의 1초 단위)쓰레드를 일시정지 상태로 잠재움.

join() join()을 호출한 쓰레드가 메인메소드가 종료될 때까지 기다림.

interrupt() 인터럽트(Waiting->Runnable) 일시정지인 상태의 쓰레드를 깨워 실행대기 상태로 만든다.

yield 쓰레드에게 주어진 시간을 다음 차례 쓰레드에게 양보?하는 기능의 메소드(0.5초는 포기후 실행대기 상태)
약간 다른 쓰레드에게 약간 짬때리는 것

Object 클래스의 메소드

synchronized 블럭 내에서만 사용가능

notify()

notifyAll()

wait()










용어:
Mapping?:
소스 위치에서 대상 위치로 데이터를 복사하고, 동시에 한 데이터 형식 유형에서 다른 유형으로 데이터를 변환하는 프로세스

***
interrupt: cpu가 특정 기능을 수행하는 도중에 급하게 다른 일을 처리하고자 할때 사용할 수 있는 기능
동기:
데이터 요청과 결과가 한 자리에서 동시에 일어나는 것을 말함.
설계가 간단 직관적
단점
클라이언트가 서버에 데이터를 요청에 대한 응답이 이루어질때까지 무한정 대기해야 함. 
비동기:
데이터 요청 결과가 동시에 일어나지 않음
요청에 대한 결과가 반환되는 동안 다른작업 수행 가능!
설계가 복잡해진다.
Blocked (동기)
응답이 올때까지 계속 대기하는 상태
Nonblocked (비동기)
대기 하지 않고 자유롭게 다른 작업 가능

동시성 제어에 관한 내 생각(지금까지 배운 내용 토대로 작성):
만일 데이터베이스에서 받아온 정보들을 자료구조에 저장하게 된다면 그 자료구조를 constant pool에 또 할당을 하여
만일 한 프로세스가 점유하고 있다면 다른 프로세스가 또 접근 못하도록 

1.그 동안은 unmodifiable관련 메소드로 리턴하여 권한을 ReadOnly로 만든다. (내가 다룬건 unmodifiableList밖에 없지만..
Map 같은 경우는 없어도 따로 구현도 가능하다.)

2.임의로 예외클래스를 만들어서 데이터에 동시 접근하는 상황이 발생하면
 throw 시키고 예외처리를 미리 일으켜 사전에 방지한다.(

두 가지 방법이 떠올랐다.(임계영역 만들기 데드락 현상 방지)