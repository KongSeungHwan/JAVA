자료형과 변수

선언및 정의 방식

자료형에는

기본형(primitive type)
논리형 boolean
문자형 char (String << 얘는 변수처럼 쓰이나 사실 객체이다. 참조형 변수!)
정수형 byte int long
실수형 double float

정수형 기본형은 int, 실수형 기본형은 double이다.

만일
long변수를 정의해준다면 long a = 1235654327376476L 처럼 뒤에 L을 붙여줘야 한다.
float변수를 정의해준다면 float b = 0.1253456445f처럼 뒤에 f를 붙여줘야 한다.


참조형(reference type)
참조형 변수 안에는 주소 값이 저장된다.

기본형을 제외한 나머지?

약간 객체를 저장하는 변수 그런 개념



지역변수/전역변수
변수는 정의한 중괄호 범위에서만 유효하다고만 알면 된다.
전역변수는 우리가 자바파일을 만들때 처음 보이는 중괄호를 의미

약간 클래스를 뒤덮고 있는 중괄호를 전역 이라고보면 되고
메인메소드를 뒤덮고 있는 중괄호 부분을 지역이라고 보면 된다.

전역변수는 초기화를 시키지 않아도 기본값이 존재

하지만 지역변수는 따로 초기화를 해주지 않으면 syntax error가 뜬다.(or 쓰레기값이 저장되게 된다.(잔류값?))



제어문


조건문
if 문
if(조건문){
조건문이 참일때 실행하는 명령문
}else{
조건문이 거짓일때 실행하는 명령문
}

else if 문

if(조건문1){
조건문 1의 범위에 해당하면 실행하는 명령문들
}else if(조건문2){
조건문2의 범위에 해당하면 실행하는 명령문들
}else{
조건문1,2 범위에 해당하지 않으면 실행하는 명령문들
}

switch ~case문
switch(value){

case value1:
	break;
case value2:
	break;
case value3
	break;
default:
}(default 말고 전부 break문을 걸어줘야함 안걸어주면 위에서부터 해당 케이스문까지 전부 실행된다.)
동작방식:value가 case: 다음에 오는 값에 해당하는 경우 해당 케이스 문 안에있는 명령문을 실행






반복문

for 문
for(초기화식;조건식;증감식){
명령문
}(조건문이 참일때 계속 돌아가는 방식)
while문
while(조건문){
명령문
}(조건문이 참일때 계속 돌아가는 방식 증감식을 따로 없어 지정해줘야 함)
do~ while문
do{
}while(조건문)
while과 동작 방식은 동일하나 단 하나의 차이점이 있다면 do while문은 최소 한번은 실행 후 조건문을 따지고
실행할지 말지를 정한다.

 
출력문(시스템 객체.out객체.출력메소드)

print: 그냥 출력 메소드
println: 출력하고 다음줄로 커서 넘기기
printf: 출력하고자 하는 문자열 안에 서식문자를 활용하면 해당 메소드를 사용


Scanner/BufferedReader
입출력 객체

Scanner객체 생성(이름을 a로 놓겠음)후

해당 자료형에 맞는 변수에
a.next(),a.nextInt(),a.nextDouble() 등 해당 자료형에 맞는 메소드를 사용하여 입력 값을 받고 
변수명을 사용하여 출력하면 된다.

BufferedReader같은 경우는 나중에 배울까봐 그냥 이해 안하고 넘어갔지만
BufferedReader n = new BufferedReader(new InputStreamReader(System.in));
이게 객체 생성 방법이고
입력 메소드 n.readLine()은 리턴 값이 문자열 객체기 때문에 Wrapper Class를 이용하여 형변환을 해줘야한다!
즉
int integer = Integer.parseInt(n.readLine());(입력해야 하는 값이 정수형인 경우)
String = n.readLine();(String은 문자열 객체에 대응하기 때문에 따로 형변환이 필요없다.)
double = Double.parseDouble(n.readLine());
등 이런식으로 형변환하여 입력해주면 된다.

Scanner 객체의 안좋은점: Scanner는 시스템 자원 반환이 완벽하지 않아 성능이 그닥 좋지 못하다.
그래서 다른 입출력 객체를 생성하여 사용하는 것이 좋다!

입출력 객체 같은 경우는 입출력 예외,널 포인터 예외 처리를 해줘야 한다.
이 IOException은 해당 자료형에 일치 하지 않는 것을 입력 받게 될때 생기는 예외 사항이 바로 이것이다.
NullPointerException는 값에 아무것도 입력하지 않을 때 발생하는 예외 사항이다.
이 두 예외 사항은 try catch문으로 예외 처리를 해줘야한다!

throw해버리면, 예외가 생기면 해당 툴에서 알아서 예외 처리를 해준다.(막 이상한 빨간줄로 원인 뜨는거)


클래스의 개념
클래스란? 현실세계의 물체를 추상화하여 나타낸 것을 클래스라고 한다.
이 클래스를 이용하여 본떠서 만든 것이 객체며 인스턴스라고 한다.

클래스 구성요소
필드
생성자 메소드
(없으면 알아서 디폴트 생성자 메소드를 만들어 줌(단 1개라도 만들어져있다면 디폴트 생성자를 만들어주지 않는다.))
메소드

메소드 오버로딩: 같은 클래스 내에서 동일한 이름의 메소드를 2개이상 정의가능한 기능!
(구분은 매개변수 자료형, 개수, 순서로 구분한다!)
메소드 오버라이딩: 부모클래스에서 정의한 메소드를 자식클래스에서 재정의할 수 있는 기능!


상속(예약어 extends 사용)
부모클래스 즉 상위클래스에서 하위 클래스에게 부모클래스에게 있던 필드와 메소드를 물려주는 것을 상속이라고 한다.

+)또한 상식으로 알아둬야할 사항은
Object클래스는 모든 클래스의 상위 클래스이다.(최상위 클래스 Object)

상속 받은 자식클래스의 생성자는 반드시 부모 생성자를 호출해야 한다.

추상클래스(예약어 abstract 사용)
추상메소드(미구현 메소드,중괄호부분을 비워 놓은 메소드)를 포함하고 있는 클래스를 추상클래스라고 한다.

추상클래스를 상속받는 클래스들은 추상메소드를 오버라이딩하여 구현을 해야한다.

추상클래스는 왜 사용하는가?
컴퓨터 종류는 여러가지이다.(데스크탑, 노트북) 또한 전원을 키는 방식 또한 모델마다 다를 것이다.
이를 컴퓨터로 추상화 하기위해 만들어진 개념이 추상 클래스이다.기능을 달리하는 부분을 정확히 짚어보자면
추상메소드 부분이다.


템플릿 메소드(final 키워드 사용)
템플릿 메소드는 같은 종류의 클래스들의 동작하는 메소드들을 시나리오 순서대로 호출할 수 있도록 모아놓은 메소드

재정의 불가능


인터페이스(예약어 implements)
규약해놓는 것을 인터페이스라고한다.(프로토콜과 같은 개념, 호환성 관련)

개발자마다 각자 변수명, 메소드명 또한 필드,메소드,리턴 값 등등 프로그램 구조가 다를 수 있다. 근데 이것들을 통일 시키기 위해
규약해놓은 것을 인터페이스라고 한다. 

이 인터페이스가 있음에 개발자가 프로그램이 만들어진 후 이어 기능을 추가 개발하고, 유지보수 할 수 있는 것이다. 
(인터페이스가 없으면 리팩토링 해야함.(개고생))



이정도면 충분!(안보고 다 읊거나 다 칠 수 있음)
