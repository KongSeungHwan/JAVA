*오류
프로그램 실행 중에 비정상적으로 종료되거나 팝업창이 뜨는 현상의 원인

ⓐError
복구 불가능한 오류
ex) Stack Overflow, Heap Overflow 등

Compile Error
컴파일 도중에 발생하는 오류
Runtime Error
프로그램 실행 중에 발생하는 오류
Logical Error
위의 두 오류와 달리 개발자의 의도와는 관계 없이 일어나는 오류


ⓑException
복구 가능한 오류
ex)NullPointerException,ArraysIndexBoundsException...

1.try~catch~finally
try문은 1번 실행되지만 예외가 일어나면 예외가 일어난 곳까지만 실행하고 try문을 나온다.
catch문은 try문에서 잡은 예외를 처리할때 사용하는 실행절이다.
finally문은 try,catch작업과 관계없이 무조건 실행하는 실행절이다.

시스템 자원 반환 방법 2가지

try 소괄호를 붙여 객체를 생성하게 되면 자동적으로 try문을 나가게 되면 시스템 자원 자동 반환

Closable 인터페이스를 상속받아  close 함수를 오버라이딩하여 시스템 자원 자동 반환



2.Exception을 상속받은 클래스를 throw 예약어를 사용해서 의도하여 일으켜 사전에 방지

3.throws를 사용하여 해당 메소드를 호출한 곳에 예외 처리 책임을 전가하는 방법


+)FileNotFoundException은 IOException의 자식클래스이다.


파일 입출력

Stream?
실제 입력이나 출력이 표현된 데이터의 이상화된 흐름
(입출력 장치와 프로그램 간의 중재자 형태로 해결하는 하나의 방법)



입력 클래스

InputStream

Reader

출력 클래스

OutputStream

Writer


버퍼링
버퍼링(buffering)이란 버퍼를 활용하는 방식 또는 버퍼를 채우는 동작


*버퍼링 방식 2가지
완전 버퍼링
버퍼가 가득 차면 목적지에 보내는 방식
라인 버퍼링
문자가 나타날때마다 목적지에 보내는 방식


***대입연산자 리턴 값: 왼쪽 피연산자를 리턴한다.
파일 데이터 출력 시에 유용하다.(마지막 값 다음 값이 -1로 리턴 되게끔 설계)


PrintStream객체는 파일이 없어도 자동 생성해주는 기능이 있다.

PrintStream의 생성자 2번째 파라미터를 true로 바꿔 주게 된다면 자동으로 flush메소드를 호출하여
버퍼를 비워주는 기능을 한다.

hasNext 메서드를 사용하여 입력 소스에 다음 토큰이 존재하는지 
확인한 후에 nextInt 메서드를 호출하는 것이 안전

무작정nextInt로 받아오는 것은 안정적이지 못하다.



함수형 프로그래밍
오로지 함수만 호출하려는 목적으로 만든 기법이다. 보통 function을 호출 시에 클래스 정의,객체 생성
메소드 호출 이 세 과정을 거쳐야만 호출이 가능했으나 그것을 한 과정으로 간편화 시킨 프로그래밍

Lambda Function
함수형 프로그래밍중 하나



람다식은 메소드를 호출 시에 객체생성후에 메소드를 호출해야하는 과정이 필요한데 
이 과정을 최대한 줄인 형태로 구현한 것으로 보면 된다.


****메소드 vs 함수
메소드란 클래스 내부에서 정의된 형태를 메소드라고 한다.
단, 함수는 객체 생성과 상관없이 독립적으로 정의된 형태를 함수라고 한다.
막 부르면 안된다 이제

람다식 사용법
인터페이스 구현 >> 함수를 객체처럼 자료형이 해당 인터페이스인 참조형 변수에 초기화
>> 참조형 변수.구현한 함수명(파라미터1,파라미터2...) 이런식으로 호출

참조타입으로 변환


암기 부분(밑으로)

:: Method Reference
(연습!)
메소드 참조
클래스명::메소드명 or 참조변수명::메소드명

생성자 참조
//클래스명::new



Stream 사용법***
List,Set,배열,Queue 자료형 변수.stream(배열이면 배열 변수명).filter/map( 조건식).collect()
.forEach/count(인자로 받아 함수작성)
map, filter, collect 부분을 따지면서 반복된다. (기본 나머지는 찾아봐야 함)

자료구조 클래스>>스트림 생성 >> 중간연산(조건식) >> 끝 연산(리턴 값 조정)

중간 연산
filter는 조건식을 넣는 자리인데, 해당 조건에 맞는 변수들을 최종연산에서 출력한다.

map은 객체의 특정 필드 값을 최종연산에서 다룰때 사용

map.collect(Collectors.(to+인터페이스 형식임)) >> 해당 인터페이스 형태로 리턴
+) 
toList() List 인터페이스 형식으로 리턴
toSet() Set 인터페이스 형식으로 리턴
toMap(key,value) Map 인터페이스 형식으로 리턴
joining() 하나의 문자열로 연결함
grouping() 스트림의 요소를 그룹화하여 맵으로 수집


단 스트림 연산은 for문 연산보다 늦게 도입되었으므로 컴파일에 최적화가 잘 이루어져있지 않다!

