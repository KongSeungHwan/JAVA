메소드 오버로딩
메소드 오버로딩은 한 클래스 내에서 같은 이름의 메소드를 여러 개 만들어서 달리 사용할 수 있는 기능
구분자는 파라미터의 개수 자료형 순서로 구분한다고 한다.

메소드 오버라이딩
부모클래스에서 정의한 메소드를 자식 클래스에서 재정의 할 수 있는 기능


필기
static 선언에 관하여

static 클래스일때는 설계서만 static 메모리에 올라가서 만들어진 객체는 공용으로 쓰이진 않음.

static 메소드면.. 객체먼저 올라가고 메소드가 올라가나 아니면 메소드만?
메소드 저장공간이 따로 있어 그 메모리 공간에 메소드만 올라감


오류(Error)



오류/예외
시스템 오류

스택 오버플로우, 힙 오버플로우 등
스택 오버플로우:

스택 메모리는 메모리 공간에서 변수,주소값이 저장되는 공간인데 이 영역이 힙 영역으로 넘어갈 때
이 현상을 스택 오버플로우라고 한다.
반대로 힙 영역에서 스택 영역으로 침범할 때 힙 오버플로우라고 함




숫자값 초기화 예외

입출력 예외(IOException)

인덱스 범위 예외

클래스 캐스팅 예외


NullPointerException 존재하지 않은 값을 포인터가 가리킬 때





1.try{}catch(){}catch(){}....finally{}
try 안의 실행문에서 예외를 잡으며 catch구문은 try문에서 예외가 발생했을 경우 이행하는 실행문
 finally는 무조건 실행되는 실행문(예외가 발생해도 실행!)

2.메소드 뒤에 throws ...(해당 메소드를 호출한 메소드가 예외처리 하도록 처리)

그러면 메인 메소드에서 throws하면 어디서 처리하는 거여 JVM에 짬때리기
자동 호출인가 StackTrace?(보통 이걸로 뜨던데)

3.예외 클래스 만들어서 오류 잡기
예외 클래스 중 제일 위 클래스 Exception**



Absolute Path/Relative Path >>리눅스 배울때 외움

절대 경로? 
해당 파일이 시스템에서 실제로 어디에 위치해있는지 표기하는 모든 경로

상대경로?
해당 디렉터리에서 출발하여 해당파일이 어디에 위치해있는지 표기하는 경로

단 상대 경로는 데이터 손실 가능성이 존재한다.(시스템 구조가 변할 시)



자바에서는 경로를 표기할 시 이스케이프 문을 포함시켜야 잘 구동한다.(\\ 문자열에 \표기 할 때의 이스케이프 문)
상대경로는 src 디렉터리까지는 꼭 표기해야 한다.
next() >>띄어쓰기를 한 단위로 출력함. 이 다음에 nextLine을 호출하면 나머지 전부 한줄로 리턴
nextLine() >>파일의 다음 줄을 한 줄의 문자열로 리턴한다.

자동 시스템 자원 반환방법(try~catch문)
객체 생성시 해당 클래스에 AutoClosable인터페이스를 상속 후 close메소드를 오버라이딩하여 처리


Map으로 처리하는 게 나을지도?(ID는 중복되면 안된다, 영문자, 특수문자, 숫자 포함여부)
Map은 Collection Framework가 아니다!
규모가 크지 않으니 필요x(어거지로 구현해 봄)


파일 입출력
처음에 Scanner쓸때 학교 교수님께 혼난 기억이 있어 BufferedReader로 고쳤다.
시스템 자원 반환이 잘 이루어지지 않아 바꾸라고 하셨었다.(입력 부분)

File?

RandomAccessFile?

**패키지 안에 폴더를 생성시에 패키지로 취급되어 뜬다.(src 내부에서는 그렇게 인식되는 것 같다.)


FileSeparator 굳이 안써도 된다. 차라리 escape문이 쉽고 빠르다.(성능차이 없음)


getAbsolutePath()
절대경로 반환

getCanonicalPath()
상대경로나 링크 등을 해결한 후 절대 경로로 반환
파일 시스템의 구현과 무관하게 항상 올바른 경로를 반환


getProperty()?
시스템의 속성(property) 값을 읽어오는 메서드



FileWriter 객체
생성자 파라미터 >> 파일 경로(상대,절대)

write메소드 사용 후 반드시 close 메소드 호출해줘야 저장된다.
파일이 없을 시 자동으로 만들어서 써준다.


성능을 고려하여 FileWriter 대신 BufferedWriter를 사용하는 것이 좋음
(버퍼 자체 만든 의도가 성능을 최대치로 하기 위해 사용되는 메모리 공간이다.)

이미 있을 경우 덮어쓰기 기능



**성능올리기 
BufferedInputStream
BufferedOutputStream
이 둘은 덮어 쓰기 기능이 불가능하며 버퍼 메모리 공간 활용을 하여 더 입출력 속도가 빠르다.


버퍼vs 캐시 (Buffer vs Cache)
버퍼는 장치의 입출력 속도를 최대한으로 성능을 뽑아내기 위해 존재하는 메모리 공간이다.
하지만 캐시는 성능을 높이기 위해서라기보다는 cpu와 보조기억장치 간의 성능차이를 줄이기 위해 존재하는 메모리 공간이다.
(cpu는 연산 속도가 빠르지만 보조기억장치는 그 연산속도에 비해 느린 편에 속한다.)






용어
MS949:한국어판 Microsoft Windows의 기본 코드 페이지로, 한글 인코딩의 한 종류이며 EUC-KR의 확장형


질문거리:
1.jsp는 굳이 src 디렉터리까지 안나와도 상대경로가 가능한데
왜 java는 src 디렉터리까지 나와야 상대경로가 가능한가?

2.그러면 같은 파일이 이미 존재한다면? 예외인가 덮어쓰기인가?(실험)