Structure Query Language
SQL 종류

DDL(Data Definition Language)
CREATE
ALTER
DROP
TRUNCATE(DROP 기능+ 시스템 자원 반환)

DML(Data Manipulation Language)
SELECT
INSERT
DELETE
UPDATE

DCL(Data Control Language)
GRANT
REVOKE

TCL(Transaction Control Language)
COMMIT
ROLLBACK



DDL(Data Definition Language)

CREATE 문 사용법((CREATE) 또는 (CREATE OR REPLACE))

CREATE TABLE AS (SELECT 문)

SELECT문으로 찾은 또 다른 가상 테이블, 뷰를 만들어 추가함

CREATE TABLE 테이블명(
칼럼명 자료형 제약조건...
);
OR
CREATE TABLE 테이블명(
칼럼명 자료형 제약조건...
CONSTRAINT 또 다른 제약조건
REFERENCES 테이블명(칼럼명) ON DELETE CASCADE << 해당 칼럼을 참조(외래키)하는 엔티티 모두 삭제
); << 뒷 부분에 더 추가 가능

제약 조건
PRIMARY KEY
FOREIGN KEY
NOT NULL
UNIQUE



ALTER TABLE 테이블명
ADD 칼럼명
ADD CONSTRAINT (새로 추가할 칼럼명) 

+)REFERENCES (참조 테이블명)( (참조 칼럼명) ) (ON DELETE CASCADE)/(ON UPDATE CASCADE);


ALTER TABLE
MODIFY (칼럼명) (바꿀 자료형)
RENAME COLUMN (기존 칼럼명) TO (갱신할 칼럼명)
DROP (칼럼명)


DML(Data Manipulation Language)

SELECT

SELECT (DISTINCT) <<중복 제거   찾을 칼럼1,찾을 칼럼2... or *(전체 칼럼)
FROM 테이블명 <<(만약에 다른 DB랑 겹친다면 DB명.TABLE명 해주면 된다.)
(WHERE 절)
(GROUP BY 절)
(ORDER BY 절)

SELECT문 연산 순서
FROM > WHERE > GROUP BY > HAVING > SELECT > ORDER BY



찾을 칼럼에 들어갈 요소들
함수(리턴 값: 숫자)
COUNT(*) 엔티티 수
MAX(칼럼명) 최댓값
MIN(칼럼명) 최솟값
SUM(칼럼명) 합
AVG(칼럼명) 평균

*** TRUNC(칼럼명) TIME, NUMBER 등 특정 자료형을 자를 때 사용하는 함수 드럽게 많다
NVL(TO_자료형(칼럼명), 대체 값) NULL인 값 변환
NVL2(칼럼명, 값1, 값2) 칼럼이 NULL이면 값1적용 NULL이 아닐경우 값2를 적용



+)별칭 (칼럼명) AS (칼럼 대체명) << AS 생략 가능
*가독성

CASE 찾을 요소란 또는 WHERE 절의 칼럼 값 란에 표기 가능 

CASE
WHEN 조건 THEN  (실행문) 또는 (칼럼 값) 
WHEN 조건 THEN  (실행문) 또는 (칼럼 값)
WHEN 조건 THEN  (실행문) 또는 (칼럼 값) 
ELSE  (실행문) 또는 (칼럼 값)   >>위의 조건 이외의 범위 모두 적용
END  (실행문) 또는 (칼럼 값)  >> 마지막 요소 적용
(when 절이 첫번째 true일 경우만 적용하고 나온다.)



ROLLUP***

CUBE***

PIVOT()***

LISTAGG(칼럼 값,구분자)
구분자 ex) ('/') , (' ,')..... 




고정 입력
SYSDATE 실행시점의 시간이 입력된다.



FROM에 붙는 절

테이블명1 CROSS JOIN 테이블명2


매칭 전부 다 시킴
TABLE1          TABLE2
col1              col2 
1	        a
2                  b
3                  c


CROSS JOIN한 테이블! 카디널 프로덕트 n대m 대응 즉 엔티티 개수는 n*m

INNER JOIN한 테이블! 교집합 (디폴트) 그냥 조인으로 써도 된다.
OUTER JOIN
	LEFT (OUTER) JOIN 좌측 테이블에만 포함되어있는 엔티티는 오른쪽 테이블에 매칭되면 붙여서 표기하고, 매칭되지 않으면 null로 처리함 
	RIGHT (OUTER) JOIN 우측 테이블에만 포함되어있는 엔티티는 왼쪽 테이블에 매칭되면 붙여서 표기하고, 매칭되지 않으면 null로 처리함 
FULL OUTER JOIN 합집합 개념
	위의  LEFT OUTER JOIN, RIGHT OUTER JOIN 모두 합치되 중복되는 데이터는 제거 함

SUB QUERY 결과가 반드시 단일! >> (SELECT문)

기본
SELECT 찾을 칼럼,....,(SELECT 문)
FROM 테이블명
WHERE절
(GROUP BY 절)
(ORDER BY 절)


SELECT문 연산 순서
FROM (테이블을 읽어옴)
WHERE (조건에 해당하는 데이터 찾기)
GROUP BY (그룹별로 분류)
HAVING (조건에 해당하는 그룹 찾기)
SELECT (조회할 칼럼 찾기)
ORDER BY(정렬)




WHERE 절
- 조건(조건을 괄호로 묶고 앞에 NOT을 붙이면 부정이 된다)


WHERE 절에 서브쿼리로 들어가는 경우(뷰로 리턴)

ALL(SELECT문) 
모든 값에 만족하는 조건

ANY(SELECT문)
하나의 값이라도 만족하는 조건

EXIST(SELECT문)
존재 여부 리턴

NOT EXIST(SELECT문)
EXIST의 부정


FROM 절  뒤에 붙는 절


ORDER BY 칼럼명 오름차순 ASC/내림차순 DESC (디폴트는 ASC!)


GROUP BY 칼럼명  칼럼 값에 따라 그룹을 나누는 절
조건부 절- HAVING 조건 (그룹의 WHERE 절이라고 보면 될 듯 하다..!)
		 IS NULL (NULL값이면 포함)

같이 쓴다면 순서는 GROUP BY, ORDER BY 순으로 써야 한다.








INSERT

INSERT INTO 테이블명 (칼럼명1,칼럼명2....) <생략 하면 전부 순서 맞춰서 기입해줘야 함
VALUES(값1,값2,값3...)


매칭 된다!
칼럼명1=값1
.
.
.

다른 방법(복합)

INSERT ALL
	WHEN 조건 THEN
	INTO절(추가 실행문)
	WHEN 조건 THEN
	INTO절(추가 실행문)
	ELSE
	INTO절(추가 실행문)



DELETE

DELETE FROM 테이블명 WHERE절;





UPDATE

UPDATE 테이블명 SET (바꿀 칼럼명)=값,(바꿀 칼럼명2)=값2,... WHERE절



WHERE 절

칼럼명 (operator) 값

비교 연산자(operator)
= < > <= >= <>(not의 의미)
각 조건별 연산  AND, OR
IS NULL
IS NOT NULL


칼럼명 IN(값1,값2,값3..) <<오버로딩 SELECT문도 가능! 
>> OR의 개념 칼럼이 값1이거나 값2이거나...
조건에 맞다면 가져옴!  

칼럼명 LIKE 'ⓐ';

LIKE 전용 정규 표현식

% << 문자 0개 이상인 문자열

_ << 문자 1개

EX)
___S  4자리며 S로 끝나는 문자열 검색

%S% 중간에 S가 들어가는 문자열 검색




DCL(Data Control Language)

계정 정의나 수정은 DDL사용 가능

CREATE USER (계정 이름) IDENTIFIED BY (비밀번호)
CREATE ROLE (역할 이름);

ALTER USER (계정 이름) IDENTIFIED BY (변경할 비밀번호)
DROP USER (계정 이름)

GRANT 권한 부여

GRANT (CONNECT/RESOURCE/CREATE/...) VIEW TO (USER/ROLE이름);

REVOKE 권한 박탈

REVOKE  (CONNECT/RESOURCE/CREATE/...) ON (테이블명) FROM (USER/ROLE이름);




TCL(Transaction Control Language)

COMMIT 트랜잭션 단위로 작업을 이행!

ROLLBACK 트랜잭션 단위로 작업을 이행하기 전으로 바꿔줌


















+) 기타 추가 사항

INDEX? 
추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조

CREATE INDEX (인덱스명) ON (테이블명) ( (컬럼명1) (ASC/DESC), (컬럼명2) (ASC/DESC), ... )
디폴트 ASC! 생략가능


SEQUENCE?
몇 가지 작동을 어떤 기준에 따라 공간적 또는 시간적으로 순서를 정해 놓는 것

SEQUENCE 생성
	CREATE SEQUENCE (시퀀스명)
	INCREMENT BY (숫자) 증가량
	START WITH (숫자) 시작 값
	(NO)MINVALUE (숫자)  최소숫자 설정 여부
	(NO)MAXVALUE (숫자) 최대 숫자 설정 여부
	(NO)CYCLE 최댓값 도달 시 시작 숫자부터 다시 시작 여부
	(NO)CACHE 캐시를 사용할지 여부
	캐시를 사용하여 미리 값을 할당해 놓아서 속도가 빠르며, 동시 사용자가 많을 경우 유리
	(NO)ORDER 요청 순서대로 값 생성 여부

시퀀스 호출
	(시퀀스명).NEXTVAL
	CURRENT_VALUE 현재 시퀀스 반환






OVER() 함수

OVER함수는 ORDER BY, GROUP BY 서브쿼리를 개선하기 위해 나온 함수


그냥 칼럼 하나로 범주를 묶을 수 있는 함수로 보면 된다.


찾을 칼럼 란에 들어감


집계함수( (컬럼) ) )OVER( (정렬 순(ORDER BY ~~))


COUNT(*)OVER() : 전체행 카운트
COUNT(*)OVER(PARTITION BY 컬럼) : 그룹단위로 나누어 카운트


MAX(컬럼)OVER() : 전체행 중에 최고값
MAX(컬럼)OVER(PARTITION BY 컬럼) : 그룹내 최고값


MIN(컬럼)OVER() : 전체행 중에 최소값
MIN(컬럼)OVER(PARTITION BY 컬럼) : 그룹내 최소값


SUM(컬럼)OVER() : 전체행 합
SUM(컬럼)OVER(PARTITION BY 컬럼) : 그룹내 합


AVG(컬럼)OVER() : 전체행 평균
AVG(컬럼)OVER(PARTITION BY 컬럼) : 그룹내 평균


STDDEV(컬럼)OVER() : 전체행 표준편차
STDDEV(컬럼)OVER(PARTITION BY 컬럼) : 그룹내 표준편차

RANK()OVER(): 순위
단 동일 값일 때 동일 순위 적용

DENSE_RANK() 순위
동일 값일 때 입력순으로 적용 

FIRST_VALUE(sal) OVER()

LAST_VALUE(sal) OVER()


임시적 별명 >> AS
영속적으로 별명을 부여하는 것이 Synonym

SYNONYM(시노님)동의어
	CREATE (접근제어자(PUBLIC(모든 사용자)/PRIVATE(특정 사용자))) SYNONYM (칼럼명/테이블명...)





계층형 쿼리
오라클만 가능하다고 함
상위 칼럼과 하위 칼럼 관계가 존재 시에 사용가능 ( ex)기본 테이블 EMP의 MGR,EMPNO 칼럼 관계 존재)


찾을 칼럼 란에 사용가능한 필드들 
-LEVEL(트리 구조의 차수)

WHERE 절 자리 대체 가능!
START WITH (칼럼)=(지정 칼럼 값 (범위 최하위<=x<=최상위))
CONNECT BY PRIOR (조건 칼럼 = 상위 칼럼(역순 가능)) (AND/OR) (조건....)


문자,숫자 관련 함수
문자,숫자 다 1BYTE
한글은 글자당 3Byte  

LENGTH() 문자열 길이,숫자 자릿수 리턴
LENGTHB() 총 자료형 크기 리턴
SUBSTR(ⓐ,ⓑ) ⓐ: 적용 칼럼 ⓑ: ⓑ시작 자리 ⓑ자리부터 끝까지의 값을 리턴
SUBSTR(ⓐ,ⓑ,ⓒ) ⓐ:적용 칼럼 ⓑ: ⓑ시작 자리 ⓒ 적용할 글자 수 ⓑ부터 ⓒ자리 만큼 잘라서 리턴
INSTR(ⓐ,ⓑ) ⓐ:적용 칼럼 ⓑ: 찾을 문자 또는 숫자 ⓐ의 개별 자리 중 ⓑ 어디에 위치해있는가 리턴
INSTR(ⓐ,ⓑ,ⓒ) ⓐ:적용 칼럼 ⓑ:시작 자리 ⓒ:ⓒ번째 찾은 자리 리턴
REPLACE(ⓐ,ⓑ) ⓐ 칼럼 안의  ⓑ 문자열을 제거한 문자열 리턴
REPLACE(ⓐ,ⓑ,ⓒ) ⓐ 칼럼 안의  ⓑ 문자열을 ⓒ문자열로 바꾸고 문자열 리턴
LPAD(ⓐ,ⓑ) ⓐ 칼럼 왼쪽에  ⓑ만큼 공백을 기입한 문자열 리턴
RPAD(ⓐ,ⓑ,ⓒ) ⓐ 칼럼 왼쪽에  ⓑ만큼 ⓒ 문자를 기입한 문자열 리턴

CONCAT(ⓐ,ⓑ) ⓐ문자열과 ⓑ 문자열 이어붙인 문자열 리턴
CONCAT(ⓐ,ⓑ,ⓒ) ⓐ문자열+ⓑ문자열+ⓒ문자열인 문자열 리턴
동일 연산 ||
EX)
'a' || 'bc' || 'd f' >> 'abcd f' 리턴

(예외 만약 null이 피연산자에 있는 경우 연산시 null 리턴)


TRIM(ⓐ) ⓐ에 만일 문자열의 끝 쪽에 공백이 있다면 제거 EX) '  A  ' >> 'A'
LTRIM(ⓐ) ⓐ에 만일 문자열의 좌 측 끝 쪽에 공백이 있다면 제거
RTRIM(ⓐ) ⓐ에 만일 문자열의 우 측 끝 쪽에 공백이 있다면 제거


내림,반올림,올림
ⓕ(ⓐ) ⓐ 소수점까지 반올림
ⓕ(ⓐ,ⓑ) ⓐ숫자를 소수점 아래 ⓑ자리까지 처리

ⓕ
ROUND 반올림
CEIL 올림
FLOOR 내림

ROUND(DATE,ⓐ)
DATE 자료형 반올림 규칙 (10진수 규칙 X)

ⓐ
CC, SCC : 네 자리 연도의 끝 두자리를 기준으로 사용
→ 2016년이면 2050년 기준. 반올림할 경우 2001년으로 처리
SYYYY, YYYY, YEAR, SYEAR, YYY, YY, Y : 날짜 데이터의 해당 연, 월, 일의 7월 1일을 기준
→ 2016년 7월 1일일 경우, 2017년으로 처리
IYYY, IYY, IY, I : ISO 8601에서 제정한 날짜 기준년도 포맷을 기준
Q : 각 분기의 두 번째 달의 16일 기준
MONTH, MON, MM, RM : 각 달의 16일 기준
WW : 해당 연도의 몇 주(1~53번째 주)를 기준
IW : ISO 8601에서 제정한 날짜 기준 해당 연도의 주(WEEK)를 기준
W : 해당 월의 주(1~5번째 주)를 기준
DDD, DD, J : 해당 일의 정오(12:00:00)를 기준
DAY, DY, D : 한 주가 시작되는 날짜를 기준
HH, HH12, HH24 : 해당 일의 시간을 기준
MI : 해당 일 시간의 분을 기준




절사 함수(자르는 함수)
TRUNC(ⓐ,ⓑ)


ⓐ가 DATE 자료형인 경우


일자/요일 절사

월/일 초기화(절사 X)
ⓑ 'YEAR'
일 초기화(절사 X)
ⓑ 'MONTH'
요일 초기화(절사 X)
ⓑ 'DAY'

시간 절사
ⓑ 'DD'
분,초 절사
ⓑ 'HH24'
초 절사
ⓑ 'MI'

숫자/소수점 절사
TRUNC(ⓐ,ⓑ)
ⓐ숫자를 소수점 아래 ⓑ자리까지 절사







TO_CHAR() 다른 자료형 >> CHAR자료형
TO_NUMBER() 다른 자료형 >> NUMBER자료형
.
.
.

형변환
TO_(변환 자료형)(받은 자료형,형식) >>변환 자료형 리턴


특수 상황
시간,날짜 표기(DATE 자료형)

현재 날짜 2023.03.28 11:18:06 기준
TO_CHAR(SYSDATE, 'YYYYMMDD') => 20230328
TO_CHAR(SYSDATE, 'YYYY/MM/DD') =>2023/03/28
TO_CHAR(SYSDATE, 'YYYY-MM-DD') =>2023-03-28
TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS') =>2023-03-28 11:18:06


일부 상황 CASE문 대체 함수(비교할 기준이 단일 값일 경우)
DECODE(칼럼,비교값,칼럼을 연산한 값,비교값2,칼럼을 연산한 값2,비교값3,칼럼을 연산한 값3.... ,(앞의 범위 모두 제외한 범위에 적용할 값));
=
CASE
WHEN 칼럼 =비교값 THEN 칼럼을 연산한 값
.
.
.
ELSE 앞의 범위 모두 제외한 범위에 적용할 값
END









PL/SQL(Procedural Language Extension to SQL)


프로시저 생성

CREATE PROCEDURE (프로시저명)
AS(IS)
DECLARE 절 (선언부)
BEGIN 절 (실행부)
EXCEPTION 절(예외 처리부)
END문(실행문 종료부)

이름은 END 뒤에 띄어쓰기 하고 붙여도 가능하다.


변수 선언, 초기화
(변수명) (CONSTANT(상수일 경우)) (자료형) (:=)(값);




-출력 함수 DBMS_OUTPUT.PUT_LINE(값);


ex)
A VARCHAR2 := '1111';
B CONST VARCHAR2 := '1111';



기본 PROCEDURE 예시

SQL PROCEDURE 생성 구문

CREATE PROCEDURE SEL1(
EMPNO2 IN OUT NUMBER;
ENAME2 OUT VARCHAR2;
JOB2 OUT VARCHAR2;
)
IS
BEGIN
	SELECT EMPNO,ENAME,JOB INTO EMPNO2,ENAME,JOB
	FROM EMP
	WHERE EMPNO=EMPNO2;
END;


SQL 실행 구문
EXEC SEL1(7703,ENO,ENA,JO);

DECLARE
	EMPNOPRINT NUMBER(10);
	ENAMEPRINT VARCHAR2(10);
	JOBPRINT VARCHAR2(10);
BEGIN
	SEL1(7369 ,EMPNOPRINT,ENAMEPRINT,JOBPRINT);
END;


7369?? >> (EMP테이블에서 찾을 엔티티의 EMPNO 값)

결과 값
EMPNO   ENAME  JOB        MGR      HIREDATE         SAL                      DEPTNO  
7369	SMITH	CLERK	7902	80/12/17	         800		20








실행부에 들어갈 제어문들

반복문

FOR문

FOR (인덱스) IN (시작값)...(끝 값) LOOP
	실행문
	...
	EXIT WHEN (조건)   >> 자바의 if(조건) break; 와 같음
END LOOP;

향상된 FOR문으로 추정

FOR LIST IN(단일 열 서브쿼리)
    LOOP
	
        END IF;
    END LOOP;


그냥 반복문..

LOOP

EXIT WHEN (조건)   >> 자바의 if(조건) break; 와 같음

END LOOP;



IF문
IF 조건1 THEN 실행1; 
    ELSIF 조건2 90 THEN 실행2;
    ELSE 실행3;
END IF;



***CURSOR 생성(내용 부족)


CREATE PROCEDURE (프로시저명)
(
 (변수명1) (IN/OUT/IN OUT) (자료형)
 (변수명2) (IN/OUT/IN OUT) (자료형)
 (변수명3) (IN/OUT/IN OUT) (자료형)
.
.
.
.
)

IS
	CURSOR CHECKEMP IS
	(서브쿼리)
BEGIN
	실행문
	OPEN (커서명)
	FETCH (커서명) INTO 칼럼1,칼럼2....;
	
	CLOSE (커서명);
END (커서명);

DECLARE
(변수명1) (IN/OUT) (자료형)
 (변수명2) (IN/OUT) (자료형)
 (변수명3) (IN/OUT) (자료형)




CREATE FUNCTION 함수명( (변수명) IN (자료형) )
RETURN VARCHAR2
IS
	변수명 자료형
BEGIN 
	INTO 절 포함된 SELECT문
END;


INTO 절 포함된 SELECT문 처리 예시 (찾을 항목과 순서와 자료형이 같아야함!)
ex)

함수명 뒤에 있는 소괄호 내부
V_DEPTNO(임의의 변수명)   (DEPT.DEPTNO%TYPE)<<자료형
V_DNAME(임의의 변수명)   (DEPT.DNAME%TYPE)<<자료형

SELECT DEPTNO,DNAME INTO V_DEPTNO,DNAME
FROM DEPT
WHERE V_DEPTNO = DEPTNO;














추가 내용
프로시저:일련의 쿼리를 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합
PL/SQL 절차형 SQL 언어
PL/SQL(Procedural Language Extension to SQL)
Procedure: 리턴 값 하나이상의 경우
Function: 리턴이 반드시 있는 경우
Trigger: 특정한 이벤트 발생 자동 실행
Package: 프로시저,함수,변수 등을 묶어 놓은 것
NoSQL: 비관계형 데이터베이스 유형
NLS (oN-Line System):NLS 또는 온라인 시스템(oN-Line System)은 1960년대부터 쓰였던 혁명적인 컴퓨터 협업 시스템
